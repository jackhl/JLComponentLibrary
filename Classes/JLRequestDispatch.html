<!DOCTYPE HTML>
<html>
	<head>
		<meta http-equiv="Content-Type" content="html/html; charset=utf-8" />
		<title>JLRequestDispatch Class Reference</title>
		<meta id="xcode-display" name="xcode-display" content="render"/>
		<meta name="viewport" content="width=550" />
		<link rel="stylesheet" type="text/css" href="../css/styles.css" media="all" />
		<link rel="stylesheet" type="text/css" media="print" href="../css/stylesPrint.css" />
		<meta name="generator" content="appledoc 2.1 (build 840)" />
	</head>
	<body>
		<header id="top_header">
			<div id="library" class="hideInXcode">
				<h1><a id="libraryTitle" href="../index.html">JLComponentLibrary </a></h1>
				<a id="developerHome" href="../index.html">Jack</a>
			</div>
			
			<div id="title" role="banner">
				<h1 class="hideInXcode">JLRequestDispatch Class Reference</h1>
			</div>
			<ul id="headerButtons" role="toolbar">
				<li id="toc_button">
					<button aria-label="Show Table of Contents" role="checkbox" class="open" id="table_of_contents"><span class="disclosure"></span>Table of Contents</button>
				</li>
				<li id="jumpto_button" role="navigation">
					<select id="jumpTo">
	<option value="top">Jump To&#133;</option>
	
	<option value="overview">Overview</option>
	
	
	
	
	<option value="tasks">Tasks</option>
	
	
	
	
	
	
	
	<option value="class_methods">Class Methods</option>
	
	<option value="//api/name/cancelAllRequests">&nbsp;&nbsp;&nbsp;&nbsp;+ cancelAllRequests</option>
	
	<option value="//api/name/clearCache">&nbsp;&nbsp;&nbsp;&nbsp;+ clearCache</option>
	
	<option value="//api/name/dispatchManagableRequestForResourceAtURL:shouldCache:timeoutInterval:progress:completion:">&nbsp;&nbsp;&nbsp;&nbsp;+ dispatchManagableRequestForResourceAtURL:shouldCache:timeoutInterval:progress:completion:</option>
	
	<option value="//api/name/dispatchManagableRequestForResourceAtURL:shouldCache:timeoutInterval:progress:processing:serialQueue:orderedCompletion:">&nbsp;&nbsp;&nbsp;&nbsp;+ dispatchManagableRequestForResourceAtURL:shouldCache:timeoutInterval:progress:processing:serialQueue:orderedCompletion:</option>
	
	<option value="//api/name/dispatchRequestForResourceAtURL:shouldCache:completion:">&nbsp;&nbsp;&nbsp;&nbsp;+ dispatchRequestForResourceAtURL:shouldCache:completion:</option>
	
	<option value="//api/name/dispatchRequestForResourceAtURL:shouldCache:processing:serialQueue:orderedCompletion:">&nbsp;&nbsp;&nbsp;&nbsp;+ dispatchRequestForResourceAtURL:shouldCache:processing:serialQueue:orderedCompletion:</option>
	
	
	
	
	
</select>
				</li>
			</ul>
		</header>
		<nav id="tocContainer" class="isShowingTOC">
			<ul id="toc" role="tree">
				
<li role="treeitem"><span class="nodisclosure"></span><span class="sectionName"><a href="#overview">Overview</a></span></li>




<li role="treeitem" id="task_treeitem"><span class="nodisclosure"></span><span class="sectionName"><a href="#tasks">Tasks</a></span><ul>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#task_Request Dispatching">Request Dispatching</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#task_Managable Request Dispatching">Managable Request Dispatching</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#task_Cache Management">Cache Management</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#task_Request Management">Request Management</a></span></li>
	
</ul></li>







<li role="treeitem" class="children"><span class="disclosure"></span><span class="sectionName"><a href="#class_methods">Class Methods</a></span><ul>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/cancelAllRequests">cancelAllRequests</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/clearCache">clearCache</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/dispatchManagableRequestForResourceAtURL:shouldCache:timeoutInterval:progress:completion:">dispatchManagableRequestForResourceAtURL:shouldCache:timeoutInterval:progress:completion:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/dispatchManagableRequestForResourceAtURL:shouldCache:timeoutInterval:progress:processing:serialQueue:orderedCompletion:">dispatchManagableRequestForResourceAtURL:shouldCache:timeoutInterval:progress:processing:serialQueue:orderedCompletion:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/dispatchRequestForResourceAtURL:shouldCache:completion:">dispatchRequestForResourceAtURL:shouldCache:completion:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/dispatchRequestForResourceAtURL:shouldCache:processing:serialQueue:orderedCompletion:">dispatchRequestForResourceAtURL:shouldCache:processing:serialQueue:orderedCompletion:</a></span></li>
	
</ul></li>




			</ul>
		</nav>
		<article>
			<div id="contents" class="isShowingTOC" role="main">
				<a title="JLRequestDispatch Class Reference" name="top"></a>
				<div class="main-navigation navigation-top">
					<ul>
	<li><a href="../index.html">Index</a></li>
	<li><a href="../hierarchy.html">Hierarchy</a></li>
</ul>
				</div>
				<div id="header">
					<div class="section-header">
						<h1 class="title title-header">JLRequestDispatch Class Reference</h1>
					</div>		
				</div>
				<div id="container">	
					
					<div class="section section-specification"><table cellspacing="0"><tbody>
						<tr>
	<td class="specification-title">Inherits from</td>
	<td class="specification-value">NSObject</td>
</tr><tr>
	<td class="specification-title">Declared in</td>
	<td class="specification-value">JLRequestDispatch.h<br />JLRequestDispatch.m</td>
</tr>
						</tbody></table></div>
					
					
					
					
					<div class="section section-overview">
						<a title="Overview" name="overview"></a>
						<h2 class="subtitle subtitle-overview">Overview</h2>
						<p>Dispatches cachable threaded network requests with completion blocks.</p>

<p>JLRequestDispatch is useful for &ldquo;set it and forget it&rdquo; network requests that need
to execute discrete behavior on completion. JLRequestDispatch efficiently manages
multiple concurrent threads as well as data caching among other nifty tools.</p>

<p>While not strictly enforced, you should refrain from initializing your own instance
of JLRequestDispatch and instead rely on the class methods provided.</p>

<p><strong>To Do</strong>:</p>

<ul>
<li>Improved parameter validation.</li>
<li>Verify that memory management and dispatching works in end cases.</li>
<li>Performance/memory management testing.</li>
<li>Better (public) unit testing.</li>
<li>Grouped caches.</li>
<li>POST requests.</li>
<li>Dependency graphs.</li>
<li>Reachability.</li>
</ul>
<div class="note"><p><strong>Note:</strong> Block-based callbacks will never be called on the main thread so if you
need to update UI you should dispatch a block with your UI updates onto the main
thread.</p></div>
					</div>
					
					
					
					
					
					<div class="section section-tasks">
						<a title="Tasks" name="tasks"></a>
						<h2 class="subtitle subtitle-tasks">Tasks</h2>
						
						
						<a title="Request Dispatching" name="task_Request Dispatching"></a>
						<h3 class="subsubtitle task-title">Request Dispatching</h3>

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/dispatchRequestForResourceAtURL:shouldCache:completion:">+&nbsp;dispatchRequestForResourceAtURL:shouldCache:completion:</a></code>
		<span class="tooltip"><p>Dispatches an asynchronous request for the resource at the specified URL.
Executes a completion block when the request returns.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/dispatchRequestForResourceAtURL:shouldCache:processing:serialQueue:orderedCompletion:">+&nbsp;dispatchRequestForResourceAtURL:shouldCache:processing:serialQueue:orderedCompletion:</a></code>
		<span class="tooltip"><p>Dispatches an asynchronous request for the resource at the specified URL.
Executes a completion block when the request returns.</p></span>
	</span>
	
	
</li>
						</ul>
						
						
						<a title="Managable Request Dispatching" name="task_Managable Request Dispatching"></a>
						<h3 class="subsubtitle task-title">Managable Request Dispatching</h3>

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/dispatchManagableRequestForResourceAtURL:shouldCache:timeoutInterval:progress:completion:">+&nbsp;dispatchManagableRequestForResourceAtURL:shouldCache:timeoutInterval:progress:completion:</a></code>
		<span class="tooltip"><p>Dispatches a managable asynchronous request for the resource at the specified
URL. Periodically calls a progress block with the amount of data downloaded and
executes a completion block when the request finishes. Allows management of
progress, cancellation, and timeout.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/dispatchManagableRequestForResourceAtURL:shouldCache:timeoutInterval:progress:processing:serialQueue:orderedCompletion:">+&nbsp;dispatchManagableRequestForResourceAtURL:shouldCache:timeoutInterval:progress:processing:serialQueue:orderedCompletion:</a></code>
		<span class="tooltip"><p>Dispatches a managable asynchronous request for the resource at the specified
URL. Periodically calls a progress block with the amount of data downloaded and
executes a completion block when the request finishes. Allows management of
progress, cancellation, and timeout.</p></span>
	</span>
	
	
</li>
						</ul>
						
						
						<a title="Cache Management" name="task_Cache Management"></a>
						<h3 class="subsubtitle task-title">Cache Management</h3>

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/clearCache">+&nbsp;clearCache</a></code>
		<span class="tooltip"><p>Flushes the cache.</p></span>
	</span>
	
	
</li>
						</ul>
						
						
						<a title="Request Management" name="task_Request Management"></a>
						<h3 class="subsubtitle task-title">Request Management</h3>

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/cancelAllRequests">+&nbsp;cancelAllRequests</a></code>
		<span class="tooltip"><p>Cancels all scheduled and currently executing requests</p></span>
	</span>
	
	
</li>
						</ul>
						
					</div>
					
					
					
					
					
					
					
					<div class="section section-methods">
						<a title="Class Methods" name="class_methods"></a>
						<h2 class="subtitle subtitle-methods">Class Methods</h2>
						
						<div class="section-method">
	<a name="//api/name/cancelAllRequests" title="cancelAllRequests"></a>
	<h3 class="subsubtitle method-title">cancelAllRequests</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Cancels all scheduled and currently executing requests</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (void)cancelAllRequests</code></div>

    
	
	
	
	
	
	
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">JLRequestDispatch.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/clearCache" title="clearCache"></a>
	<h3 class="subsubtitle method-title">clearCache</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Flushes the cache.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (void)clearCache</code></div>

    
	
	
	
	
	
	
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">JLRequestDispatch.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/dispatchManagableRequestForResourceAtURL:shouldCache:timeoutInterval:progress:completion:" title="dispatchManagableRequestForResourceAtURL:shouldCache:timeoutInterval:progress:completion:"></a>
	<h3 class="subsubtitle method-title">dispatchManagableRequestForResourceAtURL:shouldCache:timeoutInterval:progress:completion:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Dispatches a managable asynchronous request for the resource at the specified
URL. Periodically calls a progress block with the amount of data downloaded and
executes a completion block when the request finishes. Allows management of
progress, cancellation, and timeout.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (JLRequestDispatchOperation *)dispatchManagableRequestForResourceAtURL:(NSURL *)<em>url</em> shouldCache:(BOOL)<em>shouldCache</em> timeoutInterval:(NSTimeInterval)<em>timeout</em> progress:(JLRequestProgress)<em>progress</em> completion:(JLRequestCompletion)<em>completion</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>url</em></dt>
			<dd><p>The URL to use in the network request.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>shouldCache</em></dt>
			<dd><p>Instructs the dispatcher whether or not it should cache (and
attempt to retrieve from the cache) the data at the constructed URL.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>timeout</em></dt>
			<dd><p>The amount of time to wait before the connection fails.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>progress</em></dt>
			<dd><p>The progress block to invoke periodically when the connection
has received more data. Passes in the RequestDispatchOperation object, the
current length of the NSData object, and the <em>expected</em> final length of the
object. If the final length is unknown or zero, passes
RequestDispatchOperationUnknownLength.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>completion</em></dt>
			<dd><p>The completion block to invoke when the network request
returns. Passes in the received data, if any, and an NSError object (nil if no
error).</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>The operation queued to execute the network request. Useful for when
you want to cancel a request.</p>
	</div>
	
	
	
	
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">JLRequestDispatch.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/dispatchManagableRequestForResourceAtURL:shouldCache:timeoutInterval:progress:processing:serialQueue:orderedCompletion:" title="dispatchManagableRequestForResourceAtURL:shouldCache:timeoutInterval:progress:processing:serialQueue:orderedCompletion:"></a>
	<h3 class="subsubtitle method-title">dispatchManagableRequestForResourceAtURL:shouldCache:timeoutInterval:progress:processing:serialQueue:orderedCompletion:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Dispatches a managable asynchronous request for the resource at the specified
URL. Periodically calls a progress block with the amount of data downloaded and
executes a completion block when the request finishes. Allows management of
progress, cancellation, and timeout.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (JLRequestDispatchOperation *)dispatchManagableRequestForResourceAtURL:(NSURL *)<em>url</em> shouldCache:(BOOL)<em>shouldCache</em> timeoutInterval:(NSTimeInterval)<em>timeout</em> progress:(JLRequestProgress)<em>progress</em> processing:(JLRequestProcessing)<em>processing</em> serialQueue:(dispatch_queue_t)<em>serialQueue</em> orderedCompletion:(JLRequestOrderedCompletion)<em>completion</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>url</em></dt>
			<dd><p>The URL to use in the network request.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>shouldCache</em></dt>
			<dd><p>Instructs the dispatcher whether or not it should cache (and
attempt to retrieve from the cache) the data at the constructed URL.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>timeout</em></dt>
			<dd><p>The amount of time to wait before the connection fails.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>progress</em></dt>
			<dd><p>The progress block to invoke periodically when the connection
has received more data. Passes in the RequestDispatchOperation object, the
current length of the NSData object, and the <em>expected</em> final length of the
object. If the final length is unknown or zero, passes
RequestDispatchOperationUnknownLength.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>processing</em></dt>
			<dd><p>The processing block to invoke when the network request
returns. Passes in the received data, if any, and an NSError object (nil if no
error). You should return the processed data from the block, ready to be passed
into the completion block.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>serialQueue</em></dt>
			<dd><p>The serial dispatch queue to order completion blocks in. You
are free to add your own blocks to the queue. You should pass in the same serial
queue for every request in which the completion block must execute in the request
order.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>completion</em></dt>
			<dd><p>The completion block to invoke when the network request
returns. Passes in the received data, if any, and an NSError object (nil if no
error).</p></dd>
		</dl>
		
	</div>
	
	
	
	<div class="method-subsection return">
		<h4 class="method-subtitle parameter-title">Return Value</h4>
		<p>The operation queued to execute the network request. Useful for when
you want to cancel a request.</p>
	</div>
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Useful for when you want requests to execute concurrently but you want completion
blocks to execute in the order you initiated the requests. For example, you could
concurrently download and parse several paged JSON requests at the same time but
add data to a UITableView in the request order. Note that the processing block
executes in the background. It should do all of the heavy lifting to turn the
received data into a form that can be quickly consumed in an ordered manner
when the completion block executes, or it should handle the error or pass it along
to the completion block.</p><div class="warning"><p><strong>Warning:</strong> Passing in a concurrent dispatch queue results in undefined behavior.</p></div>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">JLRequestDispatch.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/dispatchRequestForResourceAtURL:shouldCache:completion:" title="dispatchRequestForResourceAtURL:shouldCache:completion:"></a>
	<h3 class="subsubtitle method-title">dispatchRequestForResourceAtURL:shouldCache:completion:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Dispatches an asynchronous request for the resource at the specified URL.
Executes a completion block when the request returns.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (void)dispatchRequestForResourceAtURL:(NSURL *)<em>url</em> shouldCache:(BOOL)<em>shouldCache</em> completion:(JLRequestCompletion)<em>completion</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>url</em></dt>
			<dd><p>The URL to use in the network request.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>shouldCache</em></dt>
			<dd><p>Instructs the dispatcher whether or not it should cache (and
attempt to retrieve from the cache) the data at the constructed URL.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>completion</em></dt>
			<dd><p>The completion block to invoke when the network request
returns. Passes in the received data, if any, and an NSError object (nil if no
error).</p></dd>
		</dl>
		
	</div>
	
	
	
	
	
	
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">JLRequestDispatch.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/dispatchRequestForResourceAtURL:shouldCache:processing:serialQueue:orderedCompletion:" title="dispatchRequestForResourceAtURL:shouldCache:processing:serialQueue:orderedCompletion:"></a>
	<h3 class="subsubtitle method-title">dispatchRequestForResourceAtURL:shouldCache:processing:serialQueue:orderedCompletion:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Dispatches an asynchronous request for the resource at the specified URL.
Executes a completion block when the request returns.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (void)dispatchRequestForResourceAtURL:(NSURL *)<em>url</em> shouldCache:(BOOL)<em>shouldCache</em> processing:(JLRequestProcessing)<em>processing</em> serialQueue:(dispatch_queue_t)<em>serialQueue</em> orderedCompletion:(JLRequestOrderedCompletion)<em>completion</em></code></div>

    
	
	<div class="method-subsection arguments-section parameters">
		<h4 class="method-subtitle parameter-title">Parameters</h4>
		
		<dl class="argument-def parameter-def">
			<dt><em>url</em></dt>
			<dd><p>The URL to use in the network request.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>shouldCache</em></dt>
			<dd><p>Instructs the dispatcher whether or not it should cache (and
attempt to retrieve from the cache) the data at the constructed URL.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>processing</em></dt>
			<dd><p>The processing block to invoke when the network request
returns. Passes in the received data, if any, and an NSError object (nil if no
error). You should return the processed data from the block, ready to be passed
into the completion block.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>serialQueue</em></dt>
			<dd><p>The serial dispatch queue to order completion blocks in. You
are free to add your own blocks to the queue. You should pass in the same serial
queue for every request in which the completion block must execute in the request
order.</p></dd>
		</dl>
		
		<dl class="argument-def parameter-def">
			<dt><em>completion</em></dt>
			<dd><p>The completion block to invoke when the network request
returns and any previous blocks in the passed in serial queue have completed.
Passes in the processed data.</p></dd>
		</dl>
		
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Useful for when you want requests to execute concurrently but you want completion
blocks to execute in the order you initiated the requests. For example, you could
concurrently download and parse several paged JSON requests at the same time but
add data to a UITableView in the request order. Note that the processing block
executes in the background. It should do all of the heavy lifting to turn the
received data into a form that can be quickly consumed in an ordered manner
when the completion block executes, or it should handle the error or pass it along
to the completion block.</p><div class="warning"><p><strong>Warning:</strong> Passing in a concurrent dispatch queue results in undefined behavior.</p></div>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">JLRequestDispatch.h</code><br />
	</div>				
	
	
</div>
						
					</div>
					
					
					
					
				</div>
				<div class="main-navigation navigation-bottom">
					<ul>
	<li><a href="../index.html">Index</a></li>
	<li><a href="../hierarchy.html">Hierarchy</a></li>
</ul>
				</div>
				<div id="footer">
					<hr />
					<div class="footer-copyright">
						<p><span class="copyright">&copy; 2013 Jack. All rights reserved. (Last updated: 2013-01-09)</span><br />
						
						<span class="generator">Generated by <a href="http://appledoc.gentlebytes.com">appledoc 2.1 (build 840)</a>.</span></p>
						
					</div>
				</div>
			</div>
		</article>
		<script type="text/javascript">
			function jumpToChange()
			{
				window.location.hash = this.options[this.selectedIndex].value;
			}
			
			function toggleTOC()
			{
				var contents = document.getElementById('contents');
				var tocContainer = document.getElementById('tocContainer');
				
				if (this.getAttribute('class') == 'open')
				{
					this.setAttribute('class', '');
					contents.setAttribute('class', '');
					tocContainer.setAttribute('class', '');
					
					window.name = "hideTOC";
				}
				else
				{
					this.setAttribute('class', 'open');
					contents.setAttribute('class', 'isShowingTOC');
					tocContainer.setAttribute('class', 'isShowingTOC');
					
					window.name = "";
				}
				return false;
			}
			
			function toggleTOCEntryChildren(e)
			{
				e.stopPropagation();
				var currentClass = this.getAttribute('class');
				if (currentClass == 'children') {
					this.setAttribute('class', 'children open');
				}
				else if (currentClass == 'children open') {
					this.setAttribute('class', 'children');
				}
				return false;
			}
			
			function tocEntryClick(e)
			{
				e.stopPropagation();
				return true;
			}
			
			function init()
			{
				var selectElement = document.getElementById('jumpTo');
				selectElement.addEventListener('change', jumpToChange, false);
				
				var tocButton = document.getElementById('table_of_contents');
				tocButton.addEventListener('click', toggleTOC, false);
				
				var taskTreeItem = document.getElementById('task_treeitem');
				if (taskTreeItem.getElementsByTagName('li').length > 0)
				{
					taskTreeItem.setAttribute('class', 'children');
					taskTreeItem.firstChild.setAttribute('class', 'disclosure');
				}
				
				var tocList = document.getElementById('toc');
				
				var tocEntries = tocList.getElementsByTagName('li');
				for (var i = 0; i < tocEntries.length; i++) {
					tocEntries[i].addEventListener('click', toggleTOCEntryChildren, false);
				}
				
				var tocLinks = tocList.getElementsByTagName('a');
				for (var i = 0; i < tocLinks.length; i++) {
					tocLinks[i].addEventListener('click', tocEntryClick, false);
				}
				
				if (window.name == "hideTOC") {
					toggleTOC.call(tocButton);
				}
			}
			
			window.onload = init;
			
			// If showing in Xcode, hide the TOC and Header
			if (navigator.userAgent.match(/xcode/i)) {
				document.getElementById("contents").className = "hideInXcode"
				document.getElementById("tocContainer").className = "hideInXcode"
				document.getElementById("top_header").className = "hideInXcode"
			}
			
		</script>
	</body>
</html>